package nl.miystengine.client;

import game.GameMain;
import io.netty.util.concurrent.GenericFutureListener;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.Proxy;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;

import javax.imageio.ImageIO;

import nl.miystengine.client.audio.AudioMaster;
import nl.miystengine.client.audio.Source;
import nl.miystengine.client.gui.FontRenderer;
import nl.miystengine.client.gui.Gui;
import nl.miystengine.client.gui.IngameGui;
import nl.miystengine.client.gui.IngameMenuAndOptionsGui;
import nl.miystengine.client.gui.LoadingScreenGui;
import nl.miystengine.client.gui.LoadingScreenMainMenu;
import nl.miystengine.client.gui.MainMenuGui;
import nl.miystengine.client.gui.ScreenGui;
import nl.miystengine.client.gui.ScaledResolution;
import nl.miystengine.client.multiplayer.NetHandlerLoginClient;
import nl.miystengine.client.multiplayer.NetHandlerPlayClient;
import nl.miystengine.client.multiplayer.PlayerControllerMP;
import nl.miystengine.client.multiplayer.WorldClient;
import nl.miystengine.client.renderer.EntityRenderer;
import nl.miystengine.client.renderer.GLAllocation;
import nl.miystengine.client.renderer.ObjectRenderer;
import nl.miystengine.client.renderer.Tessellator;
import nl.miystengine.client.renderer.entity.BasicEntityRender;
import nl.miystengine.client.renderer.entity.BasicGrassesEntityRender;
import nl.miystengine.client.renderer.entity.ModelBasic;
import nl.miystengine.client.renderer.entity.plants.EntityRenderPlantBase;
import nl.miystengine.client.renderer.terrain.RenderTerrain;
import nl.miystengine.client.renderer.terrain.Terrain;
import nl.miystengine.client.renderer.terrain.TerrainRenderer;
import nl.miystengine.client.renderer.texture.TextureManager;
import nl.miystengine.client.settings.Settings;
import nl.miystengine.client.shaders.Camera;
import nl.miystengine.client.shaders.Light;
import nl.miystengine.client.shaders.Loader;
import nl.miystengine.client.shaders.StaticShader;
import nl.miystengine.client.shaders.basicscreen.Fbo;
import nl.miystengine.client.water.WaterFrameBuffers;
import nl.miystengine.entity.Entity;
import nl.miystengine.entity.EntityClientPlayerMP;
import nl.miystengine.entity.EntityLivingBase;
import nl.miystengine.entity.EntityPlayer;
import nl.miystengine.server.management.EnumConnectionState;
import nl.miystengine.server.management.INetHandlerHandshakeServer;
import nl.miystengine.server.management.IntegratedServer;
import nl.miystengine.server.management.NetworkManager;
import nl.miystengine.util.AnimatedTimer;
import nl.miystengine.util.MathHelper;
import nl.miystengine.util.MovementInputFromOptions;
import nl.miystengine.util.ReportedException;
import nl.miystengine.util.Session;
import nl.miystengine.util.Timer;
import nl.miystengine.world.StructureWorldInfo;
import nl.miystengine.world.SettingsOfStructureWorld;

import org.apache.commons.lang3.Validate;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.lwjgl.LWJGLException;
import org.lwjgl.Sys;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.OpenGLException;
import org.lwjgl.opengl.PixelFormat;
import org.lwjgl.util.glu.GLU;
import org.lwjgl.util.vector.Vector3f;

import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Queues;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListenableFutureTask;

public class MiystEngine implements Runnable
{
	public static String acceptedSymbols = " !@#$%&*()\'+,-./1234567890:;<=>?\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
	public Settings settings;
    public TextureManager renderEngine;
    public static final Logger logger = LogManager.getLogger();
    public int canOpenAgain = 0;
    public static MiystEngine miystengine;  
    public boolean fullscreen;
    public PlayerControllerMP playerController;
    public boolean hasCrashed;
    public int displayWidth;
    public int displayHeight;
    public Timer timer = new Timer(20.0F);
    public AnimatedTimer animatedTimer = new AnimatedTimer(20.0F);
    
    public static WorldClient theWorld;
    public EntityClientPlayerMP thePlayer;
    public EntityLivingBase renderViewEntity;
    private final Session session;
    public boolean isGamePaused;
    public boolean isTimePaused;

    /** The font renderer used for displaying and measuring text. */
    public FontRenderer fontRenderer;

    /** The ScreenGui that's being displayed at the moment. */
    public ScreenGui currentScreen2;
    public static EntityRenderer entityRenderer;

    public IntegratedServer theIntegratedServer;
    public IngameGui ingameGUI;
  
    public final File location;
    private final File fileAssets;
    private final String launchedVersion;
    private final Proxy proxy;
    public static int debugFPS;
    private boolean refreshTexturePacksScheduled;
    private String serverName;
    private int serverPort;
    public boolean inGameHasFocus;
    long systemTime = getSystemTime();
    public NetworkManager myNetworkManager;
    public boolean integratedServerIsRunning;
  
    public Fbo fbo;
    public Fbo fbo_Out;
    
    public static Random rand;
    /**
     * Set to true to keep the game loop running. Set to false by shutdown() to allow the game loop to exit cleanly.
     */
    volatile boolean running = true;
    public String debug = "";
    long debugUpdateTime = getSystemTime();

    /** holds the current fps */
    public int fpsCounter;
    long prevFrameTime = -1L;
    public float scale;
    
    private boolean wasResized = false;
    private int timerResized = 0;
	private long lastFrameTime;
	private float delta;
	
	private GameMain game;

    public MiystEngine(Session s,float scale,  boolean isFullScreen, Proxy proxy,  Multimap gen_functioni_i1103_11_, String gen_functioni_i1103_12_)
    {
    	miystengine = this;
    	this.rand = new Random();
    	this.game = new GameMain();
    	//Display.sync(60);
		//Display.setVSyncEnabled(true);
    	this.location = new File(FileBasicJava.source+"/The Structure World");
    	this.scale = scale;
        this.fileAssets = this.location;
        this.launchedVersion = FileBasicJava.version;
        this.proxy = proxy == null ? Proxy.NO_PROXY : proxy;
        this.startTimerHackThread();
        this.session = s;
        this.displayWidth = 854;
        this.displayHeight = 480;
        this.fullscreen = isFullScreen;
        ImageIO.setUseCache(false);
        lastFrameTime = getCurrentTime();
      }


    public boolean wasScreenResized()
    {
    	return this.wasResized;
    }

    private void startTimerHackThread()
    {
        Thread var1 = new Thread("Timer hack thread")
        {
            public void run()
            {
                while (MiystEngine.this.running)
                {
                    try
                    {
                        Thread.sleep(2147483647L);
                    }
                    catch (InterruptedException var2)
                    {
                        ;
                    }
                }
            }
        };
        var1.setDaemon(true);
        var1.start();
    }

  

    public void setServer(String gen_functioni_71367_1_, int gen_functioni_71367_2_)
    {
        this.serverName = gen_functioni_71367_1_;
        this.serverPort = gen_functioni_71367_2_;
    }
  
    public static String Location = "The Structure World/Display.txt";
    public static int DepthBits = 24;
    public static int Samples = 8;
    
    /**
     * Starts the game.
     */
    private void startGame() throws LWJGLException, IOException, InterruptedException
    {
        try
        {
			@SuppressWarnings("resource")
			BufferedReader read = new BufferedReader(new FileReader(new File(FileBasicJava.source,Location)));
			String line = "";	
		    if(read != null && (line = read.readLine()) != null)
	        {
		    	String[] wholeSettingLine = line.split(":");
				if(wholeSettingLine[0].equals("DepthBits"))
	        	{
					DepthBits = Integer.parseInt(wholeSettingLine[1]);
				}
			} 
		    if(read != null && (line = read.readLine()) != null)
	        {
		    	String[] wholeSettingLine = line.split(":");
		    	if(wholeSettingLine[0].equals("Samples"))
		    	{
		    		Samples = Integer.parseInt(wholeSettingLine[1]);
		    	}
	        }
		}
        catch(Exception ex)
        {
	        ex.printStackTrace();
	        System.out.println("Couldn't load Display settings: "+Location);
	        System.out.println("Game will close now....");	
	        MiystEngine.miystengine.shutdownApplet();
        }
        
        if (this.fullscreen)
        {
            Display.setFullscreen(true);
        }
        else
        {
            Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
        }
        Display.setResizable(true);
        Display.setTitle("The Structure World    Version: Inprog V0.0.1");
        logger.info("LWJGL Version: " + Sys.getVersion());
        Display.setIcon(new ByteBuffer[] {this.getGame().setIcon(),this.getGame().setIcon()}); 
        try
        {
        	Display.create((new PixelFormat(4,24,0,4)).withSamples(4).withDepthBits(24));
        }
        catch (LWJGLException ex)
        {
            System.out.println("Couldn't set pixel format: "+ ex);
            try
            {
                Thread.sleep(1000L);
            }
            catch (InterruptedException var6){;}
            Display.create();
        }
        GL11.glEnable(GL13.GL_MULTISAMPLE);
        
        this.settings = new Settings();
        
        FileBasicJava.checkGLError("Startup");
        IngameMenuAndOptionsGui options = new IngameMenuAndOptionsGui();
        options.loadorwriteOptions(true); 
        Camera.creatWindow();
        FileBasicJava.checkGLError("Before EntityRender");
        this.entityRenderer = new EntityRenderer();
        FileBasicJava.checkGLError("After EntityRender");
        
        MouseControl.render = this.entityRenderer;
        this.renderEngine = new TextureManager();
        this.fontRenderer = new FontRenderer(acceptedSymbols);
        GL11.glDepthFunc(GL11.GL_LEQUAL);
        GL11.glEnable(GL11.GL_ALPHA_TEST);
        
        this.ingameGUI = new IngameGui();
        this.displayScreenGui(new LoadingScreenMainMenu());
        if (this.fullscreen)
        {
           //this.toggleFullscreen();
        }
        this.game.activatedOnStart();
   }
    
    private boolean screenLock = false;
    private static ScreenGui screenInQueue;
    
    public boolean getScreenLock()
    {
    	return this.screenLock;
    }
    
    public void setScreenLock()
    {
    	this.screenLock = true;
    	LoadingScreenGui.guiLoaded = 0;
    }
    
    public void setScreenUnLock()
    {
    	this.displayScreenGui(screenInQueue);
    	screenInQueue = null;
    	this.screenLock = false;
    }

    /**
     * Sets the argument ScreenGui as the main (topmost visible) screen.
     */
    public void displayScreenGui(ScreenGui screen)
    {
    	if(!this.screenLock)
    	{
        if(this.currentScreen2 != null)
        {
            this.currentScreen2.onGuiClosed();
        }

        if(screen == null && this.theWorld == null)
        {
        	screen = new MainMenuGui();
        	//World is null???
        }

        this.currentScreen2 = (ScreenGui)screen;

        if (screen != null)
        {
            this.setIngameNotInFocus();
            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
            int var3 = var2.getScaledWidth();
            int var4 = var2.getScaledHeight();
            ((ScreenGui)screen).setWorldAndResolution(var3, var4);
        }
        else
        {
           this.setIngameFocus();
        }}
    	else
    	{
    		screenInQueue = (ScreenGui)screen;	
    	}
    }

    public void shutdownApplet()
    {
        try
        {
            logger.info("Stopping!");
            try
            {
                this.loadStructureWorld((WorldClient)null);
            }
            catch (Throwable var7)
            {
            	var7.printStackTrace();
            }	
        }
        finally
        {
	        for(int id=0;id<TextureManager.textureList.size();++id)
	        {	
	        	 try
	             {
	        		 ++this.getTextures;
	        		 GL11.glDeleteTextures(id);
	             }
	             catch (Throwable var6)
	             {
	            	 var6.printStackTrace();
	            	 System.out.println("Texture is already gone or there is a bug in the Texture Register List?");
	            	 System.out.println("Report to the author please....");
	             }
	        }
        	
        	if(this.getTextures == TextureManager.textureList.size())
        	{
       		 System.out.println("All Textures removed successfully!");
        	}
        	
        	try
            {
	          	GL11.glDeleteLists(1, 10);
	          	GL11.glDeleteLists(2, 10);
	          	GL11.glDeleteLists(3, 10);
	          	GL11.glDeleteLists(5, 10);
	          	GL11.glDeleteLists(6, 10);
	          	GL11.glDeleteLists(7, 10);
	          	GL11.glDeleteLists(8, 10);
	          	GL11.glDeleteLists(9, 10);
	          	GL11.glDeleteLists(10, 10);
	          	GL11.glDeleteLists(11, 10);	
	          	GL11.glDeleteLists(12, 10);
            }
            catch (Throwable var6)
            {
           		var6.printStackTrace();
           		System.out.println("Something went wrong with deleting the terrain!");
           		System.out.println("Report to the author please....");
            }
        	System.out.println("Stopping OpenAL");
        	for(int i = 0;i < AudioMaster.source.size();++i)
       	 	{
        		AudioMaster.source.get(i).getSource().stop();
        		AudioMaster.source.get(i).getSource().delete();
       	 	}
        	AudioMaster.cleanUpBuffers();
            AudioMaster.cleanUp();
            
        	System.out.println("#Game closed#");
            Display.destroy();
            if (!this.hasCrashed)
            {
                System.exit(0);
            }
        }
        System.gc();
    }
    
    public int getTextures = 0;
    public int mainScreenBufferID;
    
    //Delta Time
    
	public void updateTime()
	{
		long currentFrameTime = getCurrentTime();
		delta = (currentFrameTime - lastFrameTime) / 1000f;
		lastFrameTime = currentFrameTime;
	}
	
	public float getFrameTimeSeconds()
	{
		return delta;
	}
	
	private long getCurrentTime()
	{
		return Sys.getTime() * 1000 / Sys.getTimerResolution();
	}
	
	public float getFrameTime() 
	{
		return delta;
	}
	//End
	
    public void run()
    {
        this.running = true;
        try
        {
            this.startGame();
        	System.out.println(GL11.glGetInteger(GL11.GL_DEPTH_BITS));
            FileBasicJava.checkGLError("Before Framebuffer");
            mainScreenBufferID = GL30.glGenFramebuffers();
            ScaledResolution sr = new ScaledResolution(this,this.displayWidth, this.displayHeight);
            this.currentScreen2.setWorldAndResolution(sr.getScaledWidth(), sr.getScaledHeight());
            MiystEngine.miystengine.entityRenderer.camera.creatWindow();
            FileBasicJava.checkGLError("After Start Game");
    		AudioMaster.init();
    		AudioMaster.setListenerData();
    		FileBasicJava.checkGLError("After Audio");
        }
        catch (Throwable var11)
        {
        	//Show crash report on Screen
            return;
        }
     
        while (true)
        {
            try
            {		
                while (this.running)
                {
                    if (!this.hasCrashed)
                    {
                        try
                        {
                            updateTime();
                			this.runGameLoop();
                		}
                        catch (OutOfMemoryError var10)
                        {
                            this.freeMemory();
                            
                            System.gc();
                        }
                        continue;
                    }
                  
                    return;
                }
            }
            catch (Error var12)
            {
            	var12.printStackTrace();
            }
            catch (ReportedException var13)
            {
               
                this.freeMemory();
                logger.fatal("Reported exception thrown!", var13);
             
            }
            catch (Throwable var14)
            {           
                this.freeMemory();
                logger.fatal("Unreported exception thrown!", var14);
            }
            finally
            {
            	 this.shutdownApplet();
            }
            
            return;
        }
    }
    
    public GameMain getGame()
    {
    	return this.game;
    }
    
    private void freeMemory(){}

	public int lowFPSwarning = 0;
	
    /**
     * Called repeatedly from run()
     */
    private void runGameLoop()
    {
    	FileBasicJava.checkGLError("Start Game Loop");
    	MiystEngine.miystengine.entityRenderer.camera.move();
    	 
    	if(AudioMaster.source != null)
    	{
	    	for(int i = 0;i < AudioMaster.source.size();++i)
	   	 	{
	   			AudioMaster.source.get(i).getSource().getWasPlaying();
	   	 	}
    	}
      
        if((Display.isCreated() && Display.isCloseRequested()))
        {
            this.shutdown();
        }
        
        if(this.lowFPSwarning > 3)
        {
        	System.out.println("    !Warning!     ");
        	System.out.println("!Low FPS Detected!");
        	this.lowFPSwarning = 0;
        }
        
        if(this.fpsCounter < 1)
        {
        	this.lowFPSwarning += 1;	
        }
        else
        {
        	this.lowFPSwarning = 0;		
        }
        
    	for(int i = 0;i < AudioMaster.source.size();++i)
    	{
    		if(!AudioMaster.source.get(i).getSource().isPlaying() && AudioMaster.source.get(i).getSource() != null)
     		{
    			AudioMaster.source.get(i).getSource().stop();
    			AudioMaster.source.get(i).getSource().delete();
     		}
    	}
        if(this.currentScreen2!=null && this.currentScreen2.doesGuiPauseGame())
        {
        	this.isTimePaused = true;
        }
        else if(this.isTimePaused)
        {
        	this.isTimePaused = false;
        }    
      
        if((this.isGamePaused || this.isTimePaused )&& this.theWorld != null)
        {
            float var1 = this.timer.renderPartialTicks;
            this.timer.updateTimer();
            this.timer.renderPartialTicks = var1;
            
            float var2 = this.animatedTimer.renderPartialTicks;
            this.animatedTimer.updateTimer();
            this.animatedTimer.renderPartialTicks = var2;
        }
        else
        {
            this.timer.updateTimer();
            this.animatedTimer.updateTimer();
        }
        MouseControl.checkMouseWheel();
        for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
        {
            this.runTick();
        }
        FileBasicJava.checkGLError("Before render update");
        for (float v = 0; v < this.animatedTimer.elapsedTicks; ++v)
        {    
        	if(Gui.listOfGifs != null && !Gui.listOfGifs.isEmpty())
        	{
	        	for(int i = 0;i < Gui.listOfGifs.size();++i)
	            {
	            	Gui.listOfGifs.get(i).getGifRender().updateGif();
	            }
        	}
        	
        	if(this.ingameGUI.showCommandResult > 0)
        	{
        		--this.ingameGUI.showCommandResult;
        	}
        	
        	if(this.currentScreen2 != null)
        	{
        		this.currentScreen2.updateOnSeconds();
        	}

        	this.game.updateOnDeltaTime();
        	
        	for(int id = 0;id < ObjectRenderer.ObjectsGrassesRenderList.size();++id)
        	{
        		BasicGrassesEntityRender entity = ObjectRenderer.ObjectsGrassesRenderList.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();
        		}
        	}
        	
        	for(int id = 0;id < ObjectRenderer.particles.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.particles.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();
        		}
        	}
        	
        	for(int id = 0;id < ObjectRenderer.waterObjectList.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.waterObjectList.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();
        		}
        	}
        	
        	for(int id = 0;id < ObjectRenderer.ObjectsOwnTexture.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.ObjectsOwnTexture.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();
        		}
        	}
        	
        	for(int id = 0;id < ObjectRenderer.transparantEntitys.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.transparantEntitys.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();  
        		}
        	}

        	for(int id = 0;id < ObjectRenderer.BodyParts.size();++id)
  			{
        		BasicEntityRender entity = ObjectRenderer.BodyParts.get(id).entity;
        		if(entity != null)
        		{
        			entity.updateRenderer();
        		}
  			}
  		}

        FileBasicJava.checkGLError("Before render camera");
        if(this.entityRenderer.camera != null)
        { 
            this.entityRenderer.camera.updateCameraAndRender(this.timer.renderPartialTicks);
        }
        FileBasicJava.checkGLError("After render camera");
        
        GL11.glFlush();
        if (!Display.isActive() && this.fullscreen)
        {
            this.toggleFullscreen();
        }
        this.prevFrameTime = System.nanoTime(); 
        this.wasResized();
        Thread.yield();
        ++this.fpsCounter;
        while (getSystemTime() >= this.debugUpdateTime + 1000L)
        {
            debugFPS = this.fpsCounter;
            this.debug = debugFPS + " fps, ";
            this.debugUpdateTime += 1000L;
            this.fpsCounter = 0;
        }
    }

    public void wasResized()
    {
        Display.update();

        if(this.wasResized)
        {
        	++this.timerResized;
        }
        
        if(this.timerResized > 100)
        {
        	this.wasResized = false;
        	this.timerResized = 0;
        }
        
        if (!this.fullscreen && Display.wasResized())
        {
        	this.wasResized = true;
            int var1 = this.displayWidth;
            int var2 = this.displayHeight;
            this.displayWidth = Display.getWidth();
            this.displayHeight = Display.getHeight();

            if (this.displayWidth != var1 || this.displayHeight != var2)
            {
                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }

                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }

                this.resize(this.displayWidth, this.displayHeight);
            }
        }
    }

    
    /**
     * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
     */
    public void shutdown()
    {
        this.running = false;
        if(EntityRenderer.nmr != null)
        {
        	EntityRenderer.nmr.cleanUp();
        }
    }
   
    public void setIngameFocus()
    {
        if (Display.isActive())
        {
            if (!this.inGameHasFocus)
            {
                this.inGameHasFocus = true;
                Mouse.setCursorPosition(Display.getWidth() / 2, Display.getHeight() / 2);
                Mouse.setGrabbed(true);
                this.displayScreenGui((ScreenGui)null);
            }
        }
    }

    /**
     * Resets the player keystate, disables the ingame focus, and ungrabs the mouse cursor.
     */
    public void setIngameNotInFocus()
    {
        if (this.inGameHasFocus)
        {
            this.inGameHasFocus = false;
            Mouse.setCursorPosition(Display.getWidth() / 2, Display.getHeight() / 2);
            Mouse.setGrabbed(false);
        }
    }

    /**
     * Displays the ingame menu
     */
    public void displayInGameMenu()
    {
        if (this.currentScreen2 == null)
        {
            this.displayScreenGui(new IngameMenuAndOptionsGui());
        }
    }
    
    /**
     * Toggles fullscreen mode.
     */
    public void toggleFullscreen()
    {
        try
        {
            this.fullscreen = !this.fullscreen;

            if (this.fullscreen)
            {
                this.displayWidth = Display.getDisplayMode().getWidth();
                this.displayHeight = Display.getDisplayMode().getHeight();

                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }
                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }
            }
            else
            {
             
                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }

                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }
            }
            
            if (this.currentScreen2 != null)
            {
                this.resize(this.displayWidth, this.displayHeight);
            }
         
            Display.setFullscreen(this.fullscreen);
            this.wasResized();
        }
        catch (Exception var2)
        {
            logger.error("Couldn\'t toggle fullscreen", var2);
        }
    }

    /**
     * Called to resize the current screen.
     */
    private void resize(int x, int y)
    {
    	this.displayWidth = x <= 0 ? 1 : x;
        this.displayHeight = y <= 0 ? 1 : y;
        ScaledResolution sr = new ScaledResolution(this,x, y);
        if(this.currentScreen2 != null)
        {
        	this.currentScreen2.setWorldAndResolution(sr.getScaledWidth(), sr.getScaledHeight());
        }
        
        MiystEngine.miystengine.entityRenderer.camera.creatWindow();
     
        this.entityRenderer.buffer = new WaterFrameBuffers();
    }
    
    /**
     * Runs the current tick.
     */
    public void runTick()
    {
        if(!this.isTimePaused && !this.isGamePaused &&this.theWorld != null)
        {
        	this.theWorld.updateEntities(false);
        }
        else if(this.theWorld != null)
        {
        	this.theWorld.updateEntities(true);
        }
        
        
        //source.delete();

        
        if (!this.isGamePaused)
        {
            this.ingameGUI.updateTick();
        }
        if (this.theWorld != null)
        {
            this.playerController.updateController();
        }

        if (!this.isGamePaused)
        {
            this.renderEngine.tick();
        }

        if (this.currentScreen2 != null)
        {
            try
            {
                this.currentScreen2.handleInput();
            }
            catch (Throwable var6)
            {
               
            }

            if (this.currentScreen2 != null)
            {
                try
                {
                    this.currentScreen2.updateScreen();
                }
                catch (Throwable var5)
                {
                   
                }
            }
        }

        if (this.currentScreen2 == null)
        {
            int var9;

            while (Mouse.next())
            {
                var9 = Mouse.getEventButton();
              
                if (Mouse.getEventButtonState())
                {
                }

                long var11 = getSystemTime() - this.systemTime;

                if (var11 <= 200L)
                {
                    int var4 = Mouse.getEventDWheel();

                    if (var4 != 0)
                    {
                       
                    }

                    if (this.currentScreen2 == null)
                    {
                        if (!this.inGameHasFocus && Mouse.getEventButtonState())
                        {
                            this.setIngameFocus();
                        }
                    }
                    else if (this.currentScreen2 != null)
                    {
                        this.currentScreen2.handleMouseInput();
                    }
                }
            }
            boolean var10;

            while (Keyboard.next())
            {
                if (Keyboard.getEventKeyState())
                {
                	if(this.ingameGUI != null)
                	{
                		this.ingameGUI.handleKeyboardInputs();
                	}
                    
                    if (this.currentScreen2 != null)
                    {
                        this.currentScreen2.handleKeyboardInput();
                    }
                    else
                    {
                        if (Keyboard.getEventKey() == 1)
                        {
                            this.displayInGameMenu();
                        }
                    }
                }
            }
        }
        if (this.theWorld != null)
        {
            if (!this.isGamePaused)
            {
                this.entityRenderer.updateRenderer();
            }
        }

        if (this.theWorld != null)
        {
            if (!this.isGamePaused)
            {
              
                try
                {
                    this.theWorld.tick();
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    if (this.theWorld == null)
                    {
                       System.out.println("[Client thread/ERROR]: Client World == null!");
                    }
                    else
                    {
                    	System.out.println("[Client thread/ERROR]: "+e.getMessage());
                    }
                }
            }
        }
        else if (this.myNetworkManager != null)
        {
            this.myNetworkManager.processReceivedPackets();
        }

        
        this.systemTime = getSystemTime();
    }

    /**
     * Arguments: World foldername,  World ingame name, SettingsOfStructureWorld
     */
    public void launchIntegratedServer(String worldName, String gen_functioni_71371_2_, StructureWorldInfo info)
    {
    	try
        {
	        this.loadStructureWorld((WorldClient)null);
	        System.gc();
	
	        try
	        {
	            this.theIntegratedServer = new IntegratedServer(this, worldName, gen_functioni_71371_2_);
	            this.theIntegratedServer.startServerThread();
	            this.integratedServerIsRunning = true;
	        }
	        catch (Exception e)
	        {        
	          e.printStackTrace();
	        }
	
	        while (!this.theIntegratedServer.serverIsInRunLoop())
	        {
	            try
	            {
	                Thread.sleep(200L);
	            }
	            catch (InterruptedException var9)
	            {
	                ;
	            }
	        }
	        SocketAddress var11 = this.theIntegratedServer.tsw_gen_functioni_147137_ag().addLocalEndpoint();
	        NetworkManager var12 = NetworkManager.provideLocalClient(var11);
	        var12.setNetHandler(new NetHandlerLoginClient(var12, this, new LoadingScreenGui(worldName)));
	        this.myNetworkManager = var12;
        }
        catch (Exception e)
        {        
          e.printStackTrace();
        }
    }


    public void loadStructureWorld(WorldClient worldClient)
    {
        if (worldClient == null)
        {
            NetHandlerPlayClient var3 = this.getNetHandler();

            if (var3 != null)
            {
                var3.cleanup();
            }

            if (this.theIntegratedServer != null)
            {
                this.theIntegratedServer.initiateShutdown();
            }

            this.theIntegratedServer = null;
        }

        this.renderViewEntity = null;
        this.myNetworkManager = null;

       
        if (worldClient == null && this.theWorld != null)
        {
            this.integratedServerIsRunning = false;
        }
       

        if (worldClient != null)
        {
            if (this.entityRenderer != null)
            {
                this.entityRenderer.setWorldAndLoadRenderers(worldClient);
            }

            if (this.thePlayer == null)
            {
                this.thePlayer = this.playerController.createNewPlayerMP(worldClient);
                this.playerController.flipPlayer(this.thePlayer);
                this.game.theMainPlayer = this.thePlayer;
            }

            worldClient.spawnEntityInWorld(this.thePlayer);
            this.thePlayer.movementInput = new MovementInputFromOptions();
            this.renderViewEntity = this.thePlayer;
        }
        else
        {
            this.thePlayer = null;
        }

        System.gc();
        this.systemTime = 0L;
    }

    public void setSpawnPlayer()
    {
        this.theWorld.setSpawnLocation();
        this.theWorld.removeAllEntities();
        int var2 = 0;
        String var3 = null;
        if (this.thePlayer != null)
        {
            var2 = this.thePlayer.getEntityId();
            this.theWorld.removeEntity(this.thePlayer);
            var3 = this.thePlayer.getName();
        }
        this.renderViewEntity = null;
        this.renderViewEntity = this.thePlayer;
        this.thePlayer.setName(var3);
        this.theWorld.spawnEntityInWorld(this.thePlayer);
        this.playerController.flipPlayer(this.thePlayer);
        this.thePlayer.movementInput = new MovementInputFromOptions();
        this.thePlayer.setEntityId(var2);
    }

    public NetHandlerPlayClient getNetHandler()
    {
        return this.thePlayer != null ? this.thePlayer.sendQueue : null;
    }

    /**
     * Return the singleton StructureWorld instance for the game
     */
    public static MiystEngine getMiystEngine()
    {
        return miystengine;
    }

    public void scheduleResourcesRefresh()
    {
        this.refreshTexturePacksScheduled = true;
    }

    public boolean isIntegratedServerRunning()
    {
        return this.integratedServerIsRunning;
    }

    /**
     * Returns true if there is only one player playing, and the current server is the integrated one.
     */
    public boolean isSingleplayer()
    {
        return this.integratedServerIsRunning && this.theIntegratedServer != null;
    }

    /**
     * Returns the currently running integrated server
     */
    public IntegratedServer getIntegratedServer()
    {
        return this.theIntegratedServer;
    }

    public static void stopIntegratedServer()
    {
        if (MiystEngine.miystengine != null)
        {
            IntegratedServer var0 = MiystEngine.miystengine.getIntegratedServer();

            if (var0 != null)
            {
                var0.stopServer(false);
            }
        }
    }

    /**
     * Gets the system time in milliseconds.
     */
    public static long getSystemTime()
    {
        return Sys.getTime() * 1000L / Sys.getTimerResolution();
    }

    /**
     * Returns whether we're in full screen or not.
     */
    public boolean isFullScreen()
    {
        return this.fullscreen;
    }
    
    /**
     * Returns whether we're in full screen or not.
     */
    public void setFullScreen(boolean setFullScreen)
    {
    	this.fullscreen = setFullScreen;
    }

    public Session getSession()
    {
        return this.session;
    }

    public Proxy getProxy()
    {
        return this.proxy;
    }

    public TextureManager getTextureManager()
    {
        return renderEngine;
    }
}
