package nl.thestructureworld.client;

import io.netty.util.concurrent.GenericFutureListener;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.Proxy;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import javax.imageio.ImageIO;
import nl.thestructureworld.client.audio.AudioMaster;
import nl.thestructureworld.client.audio.Source;
import nl.thestructureworld.client.gui.FontRenderer;
import nl.thestructureworld.client.gui.IngameGui;
import nl.thestructureworld.client.gui.IngameMenuAndOptionsGui;
import nl.thestructureworld.client.gui.LoadingScreenGui;
import nl.thestructureworld.client.gui.MainMenuGui;
import nl.thestructureworld.client.gui.GuiScreen;
import nl.thestructureworld.client.gui.ScaledResolution;
import nl.thestructureworld.client.multiplayer.GuiConnecting;
import nl.thestructureworld.client.multiplayer.NetHandlerLoginClient;
import nl.thestructureworld.client.multiplayer.NetHandlerPlayClient;
import nl.thestructureworld.client.multiplayer.PlayerControllerMP;
import nl.thestructureworld.client.multiplayer.ServerData;
import nl.thestructureworld.client.multiplayer.WorldClient;
import nl.thestructureworld.client.renderer.EntityRenderer;
import nl.thestructureworld.client.renderer.GLAllocation;
import nl.thestructureworld.client.renderer.ObjectRenderer;
import nl.thestructureworld.client.renderer.OpenGlHelper;
import nl.thestructureworld.client.renderer.Tessellator;
import nl.thestructureworld.client.renderer.entity.BasicEntityRender;
import nl.thestructureworld.client.renderer.entity.ModelBasic;
import nl.thestructureworld.client.renderer.terrain.RenderTerrain;
import nl.thestructureworld.client.renderer.terrain.Terrain;
import nl.thestructureworld.client.renderer.terrain.TerrainRenderer;
import nl.thestructureworld.client.renderer.texture.TextureManager;
import nl.thestructureworld.client.shaders.Framebuffer;
import nl.thestructureworld.client.shaders.Light;
import nl.thestructureworld.client.shaders.Loader;
import nl.thestructureworld.client.shaders.StaticShader;
import nl.thestructureworld.client.water.WaterFrameBuffers;
import nl.thestructureworld.entity.Entity;
import nl.thestructureworld.entity.EntityClientPlayerMP;
import nl.thestructureworld.entity.EntityList;
import nl.thestructureworld.entity.EntityLivingBase;
import nl.thestructureworld.entity.EntityPlayer;
import nl.thestructureworld.network.play.client.C00PacketLoginStart;
import nl.thestructureworld.network.play.client.C16PacketClientStatus;
import nl.thestructureworld.network.play.client.EnumConnectionState;
import nl.thestructureworld.network.play.client.INetHandlerHandshakeServer;
import nl.thestructureworld.network.play.client.IntegratedServer;
import nl.thestructureworld.network.play.client.NetworkManager;
import nl.thestructureworld.network.play.client.S0EPacketSpawnObject;
import nl.thestructureworld.util.AnimatedTimer;
import nl.thestructureworld.util.MathHelper;
import nl.thestructureworld.util.MouseHelper;
import nl.thestructureworld.util.MovementInputFromOptions;
import nl.thestructureworld.util.MovingObjectPosition;
import nl.thestructureworld.util.ReportedException;
import nl.thestructureworld.util.ResourceLocation;
import nl.thestructureworld.util.Session;
import nl.thestructureworld.util.Timer;
import nl.thestructureworld.util.Util;
import nl.thestructureworld.world.WorldSettings;
import nl.thestructureworld.world.storage.AnvilSaveConverter;
import nl.thestructureworld.world.storage.ISaveFormat;
import nl.thestructureworld.world.storage.ISaveHandler;
import nl.thestructureworld.world.storage.StructureWorldInfo;
import org.apache.commons.lang3.Validate;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.lwjgl.LWJGLException;
import org.lwjgl.Sys;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.OpenGLException;
import org.lwjgl.opengl.PixelFormat;
import org.lwjgl.util.glu.GLU;
import org.lwjgl.util.vector.Vector3f;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Queues;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListenableFutureTask;

public class TheStructureWorld implements Runnable
{
	public static String acceptedSymbols = " !@#$%&*()\'+,-./1234567890:;<=>?\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
	
    public TextureManager renderEngine;
    public static final Logger logger = LogManager.getLogger();
    public static final boolean isRunningonMac = Util.getOSType() == Util.EnumOS.OSX;
    public static byte[] memoryReserve = new byte[10485760];
    public static final List macDisplayModes = Lists.newArrayList(new DisplayMode[] {new DisplayMode(2560, 1600), new DisplayMode(2880, 1800)});
    public ServerData currentServerData;
  
    public int canOpenAgain = 0;
    
    public static TheStructureWorld TheStructureWorld;
    
    public boolean fullscreen;
    public PlayerControllerMP playerController;

    public boolean hasCrashed;
    public int displayWidth;
    public int displayHeight;
    public Timer timer = new Timer(20.0F);
    public AnimatedTimer animatedTimer = new AnimatedTimer(20.0F);
    
    public static WorldClient theWorld;
    public EntityClientPlayerMP thePlayer;
    public EntityLivingBase renderViewEntity;
    public Entity pointedEntity;
    private final Session session;
    public boolean isGamePaused;
    public boolean isTimePaused;

    /** The font renderer used for displaying and measuring text. */
    public FontRenderer fontRenderer;

    /** The GuiScreen that's being displayed at the moment. */
    public GuiScreen currentScreen;
    public static EntityRenderer entityRenderer;

    /** Mouse left click counter */
    private int leftclickCounter;

    /** Instance of IntegratedServer. */
    public IntegratedServer theIntegratedServer;

    public IngameGui ingameGUI;

    /** Skip render world */
    public boolean skipRenderWorld;

    /** The ray trace hit that the mouse is over. */
    public MovingObjectPosition objectMouseOver;

    /** The game settings that currently hold effect. */
    public GameSettings gameSettings;

    /** Mouse helper instance. */
    public MouseHelper mouseHelper;
    public final File location;
    private final File fileAssets;
    private final String launchedVersion;
    private final Proxy proxy;
    public ISaveFormat saveLoader;

    /**
     * This is set to fpsCounter every debug screen update, and is shown on the debug screen. It's also sent as part of
     * the usage snooping.
     */
    public static int debugFPS;
    private boolean refreshTexturePacksScheduled;
    private String serverName;
    private int serverPort;

    /**
     * Does the actual gameplay have focus. If so then mouse and keys will effect the player instead of menus.
     */
    public boolean inGameHasFocus;
    long systemTime = getSystemTime();
    private final boolean jvm64bit;
    public NetworkManager myNetworkManager;
    public boolean integratedServerIsRunning;
    public Framebuffer framebuffer;
   
    /**
     * Set to true to keep the game loop running. Set to false by shutdown() to allow the game loop to exit cleanly.
     */
    volatile boolean running = true;
    public String debug = "";
    long debugUpdateTime = getSystemTime();

    /** holds the current fps */
    public int fpsCounter;
    long prevFrameTime = -1L;
    public float scale;
    
    private boolean wasResized = false;
    private int timerResized = 0;
    
    public TheStructureWorld(Session s,float scale,  boolean isFullScreen, Proxy proxy,  Multimap funci_i1103_11_, String funci_i1103_12_)
    {
    	TheStructureWorld = this;
    	//Display.sync(60);
		//Display.setVSyncEnabled(true);
    	this.location = new File(FileBasicJava.source+"/The Structure World");
    	this.scale = scale;
        this.fileAssets = this.location;
        this.launchedVersion = FileBasicJava.version;
        this.proxy = proxy == null ? Proxy.NO_PROXY : proxy;
        this.startTimerHackThread();
        this.session = s;
        this.displayWidth = 854;
        this.displayHeight = 480;
        this.fullscreen = isFullScreen;
        this.jvm64bit = isJvm64bit();
        ImageIO.setUseCache(false);
        AudioMaster.init();
        AudioMaster.setListenerData();
     }

    private static boolean isJvm64bit()
    {
        String[] var0 = new String[] {"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};
        String[] var1 = var0;
        int var2 = var0.length;

        for (int var3 = 0; var3 < var2; ++var3)
        {
            String var4 = var1[var3];
            String var5 = System.getProperty(var4);

            if (var5 != null && var5.contains("64"))
            {
                return true;
            }
        }

        return false;
    }

    public boolean wasScreenResized()
    {
    	return this.wasResized;
    }

    public Framebuffer getFramebuffer()
    {
        return this.framebuffer;
    }

    private void startTimerHackThread()
    {
        Thread var1 = new Thread("Timer hack thread")
        {
            public void run()
            {
                while (TheStructureWorld.this.running)
                {
                    try
                    {
                        Thread.sleep(2147483647L);
                    }
                    catch (InterruptedException var2)
                    {
                        ;
                    }
                }
            }
        };
        var1.setDaemon(true);
        var1.start();
    }

  

    public void setServer(String funci_71367_1_, int funci_71367_2_)
    {
        this.serverName = funci_71367_1_;
        this.serverPort = funci_71367_2_;
    }

    public static Random rand = new Random();   
    public static ByteBuffer IIcon;
    
    public static void setIcon() throws IOException 
    {
    	  int icon  = rand.nextInt(4);
    	  String logo = "";
          if(icon == 1)
          {
          	 logo =	FileBasicJava.source+"/The Structure World/The Structure World Logo green.png";
          }
          if(icon == 2)
          {
          	 logo =	FileBasicJava.source+"/The Structure World/The Structure World Logo blue.png";
          }
          if(icon == 3)
          {
          	 logo =	FileBasicJava.source+"/The Structure World/The Structure World Logo purple.png";
          }
          if(icon == 4)
          {
          	 logo =	FileBasicJava.source+"/The Structure World/The Structure World Logo red.png";
          }
          if(logo == "")
          {
          	logo =	FileBasicJava.source+"/The Structure World/The Structure World Logo orange.png";
          }
          IIcon = TheStructureWorld.TheStructureWorld.getTextureManager().convertImageData(logo);
          Display.setIcon(new ByteBuffer[] {IIcon,IIcon});  
    }
    
    public static String Location = "The Structure World/Display.txt";
    public static int DepthBits = 24;
    public static int Samples = 8;
    
    /**
     * Starts the game.
     */
    private void startGame() throws LWJGLException, IOException, InterruptedException
    {
        this.gameSettings = new GameSettings(this);
        try
        {
		@SuppressWarnings("resource")
		BufferedReader read = new BufferedReader(new FileReader(new File(FileBasicJava.source,Location)));
		String line = "";	
	    if(read != null && (line = read.readLine()) != null)
        {
		String[] wholeSettingLine = line.split(":");
		if(wholeSettingLine[0].equals("DepthBits"))
        {
		DepthBits = Integer.parseInt(wholeSettingLine[1]);
		}} 
	    if(read != null && (line = read.readLine()) != null)
        {
		String[] wholeSettingLine = line.split(":");
		if(wholeSettingLine[0].equals("Samples"))
        {
		Samples = Integer.parseInt(wholeSettingLine[1]);
		}}}
        catch(Exception ex)
        {
        ex.printStackTrace();
        System.out.println("Couldn't load Display settings: "+Location);
        System.out.println("Game will close now....");	
        TheStructureWorld.TheStructureWorld.shutdownApplet();
        }
        
        if (this.fullscreen)
        {
            Display.setFullscreen(true);
        }
        else
        {
            Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
        }
        Display.setResizable(true);
        Display.setTitle("The Structure World    Version: Inprog V0.0.1");
        logger.info("LWJGL Version: " + Sys.getVersion());
        this.setIcon();
        try
        {
        	Display.create((new PixelFormat(4,24,0,4)).withDepthBits(DepthBits).withSamples(Samples));
        }
        catch (LWJGLException ex)
        {
            System.out.println("Couldn't set pixel format: "+ ex);
            try
            {
                Thread.sleep(1000L);
            }
            catch (InterruptedException var6){;}
            Display.create();
        }
        FileBasicJava.checkGLError("Startup");
        OpenGlHelper.initializeTextures();
        IngameMenuAndOptionsGui options = new IngameMenuAndOptionsGui();
        options.loadorwriteOptions(true); 
        this.framebuffer = new Framebuffer(this.displayWidth, this.displayHeight, -1);
        this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
        this.saveLoader = new AnvilSaveConverter(new File(this.location, "saves"));
        FileBasicJava.checkGLError("Before EntityRender");
        this.entityRenderer = new EntityRenderer();
        FileBasicJava.checkGLError("After EntityRender");
        
        MouseControl.render = this.entityRenderer;
        this.renderEngine = new TextureManager();
        this.renderEngine.bindTexture("/missing_texture.png", 0, false);
        this.fontRenderer = new FontRenderer(acceptedSymbols);
        this.mouseHelper = new MouseHelper();
        GL11.glDepthFunc(GL11.GL_LEQUAL);
        GL11.glEnable(GL11.GL_ALPHA_TEST);
        GL11.glEnable(GL13.GL_MULTISAMPLE);
        this.ingameGUI = new IngameGui(this);
        if (this.serverName != null)
        {
        	  this.displayGuiScreen(new GuiConnecting(new MainMenuGui(), this, this.serverName, this.serverPort));
        }
        else
        {
            this.displayGuiScreen(new MainMenuGui());
        }
        if (this.gameSettings.fullScreen && !this.fullscreen)
        {
            this.toggleFullscreen();
        }
   }
  

    /**
     * Returns the save loader that is currently being used
     */
    public ISaveFormat getSaveLoader()
    {
        return this.saveLoader;
    }
    
    private boolean screenLock = false;
    private static GuiScreen screenInQueue;
    
    public boolean getScreenLock()
    {
    	return this.screenLock;
    }
    
    public void setScreenLock()
    {
    	this.screenLock = true;
    	LoadingScreenGui.guiLoaded = 0;
    }
    
    public void setScreenUnLock()
    {
    	this.displayGuiScreen(screenInQueue);
    	screenInQueue = null;
    	this.screenLock = false;
    }

    /**
     * Sets the argument GuiScreen as the main (topmost visible) screen.
     */
    public void displayGuiScreen(GuiScreen screen)
    {
    	if(!this.screenLock)
    	{
        if(this.currentScreen != null)
        {
            this.currentScreen.onGuiClosed();
        }

        if(screen == null && this.theWorld == null)
        {
        	screen = new MainMenuGui();
        }

        if(screen instanceof MainMenuGui)
        {
            this.gameSettings.showDebugInfo = false;
        }

        this.currentScreen = (GuiScreen)screen;

        if (screen != null)
        {
            this.setIngameNotInFocus();
            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
            int var3 = var2.getScaledWidth();
            int var4 = var2.getScaledHeight();
            ((GuiScreen)screen).setWorldAndResolution(this, var3, var4);
            this.skipRenderWorld = false;
        }
        else
        {
           this.setIngameFocus();
        }}
    	else
    	{
    		screenInQueue = (GuiScreen)screen;	
    	}
    }

    public void shutdownApplet()
    {
        try
        {
            logger.info("Stopping!");
            try
            {
                this.loadWorld((WorldClient)null);
            }
            catch (Throwable var7)
            {
            	var7.printStackTrace();
            }
    		AudioMaster.cleanUp();
        }
        finally
        {
	        for(int id=0;id<TextureManager.textureList.size();++id)
	        {	
	        	 try
	             {
	        		 ++this.getTextures;
	        		 GL11.glDeleteTextures(id);
	             }
	             catch (Throwable var6)
	             {
	            	 var6.printStackTrace();
	            	 System.out.println("Texture is already gone or there is a bug in the Texture Register List?");
	            	 System.out.println("Report to the author please....");
	             }
	        }
        	
        	if(this.getTextures == TextureManager.textureList.size())
        	{
       		 System.out.println("All Textures removed successfully!");
        	}
        	
        	try
            {
	          	GL11.glDeleteLists(1, 10);
	          	GL11.glDeleteLists(2, 10);
	          	GL11.glDeleteLists(3, 10);
	          	GL11.glDeleteLists(5, 10);
	          	GL11.glDeleteLists(6, 10);
	          	GL11.glDeleteLists(7, 10);
	          	GL11.glDeleteLists(8, 10);
	          	GL11.glDeleteLists(9, 10);
	          	GL11.glDeleteLists(10, 10);
	          	GL11.glDeleteLists(11, 10);	
	          	GL11.glDeleteLists(12, 10);
            }
            catch (Throwable var6)
            {
           		var6.printStackTrace();
           		System.out.println("Something went wrong with deleting the terrain!");
           		System.out.println("Report to the author please....");
            }
        	
        	System.out.println("#Game closed#");
            Display.destroy();
            if (!this.hasCrashed)
            {
                System.exit(0);
            }
        }
        System.gc();
    }
    
    public int getTextures = 0;
    public int mainScreenBufferID;
    private static long lastFrameTime;
	private static float delta;
	
    public void run()
    {
        this.running = true;
        try
        {
            this.startGame();
            FileBasicJava.checkGLError("Before Framebuffer");
            mainScreenBufferID = GL30.glGenFramebuffers();
            ScaledResolution sr = new ScaledResolution(this,this.displayWidth, this.displayHeight);
            this.currentScreen.setWorldAndResolution(this, sr.getScaledWidth(), sr.getScaledHeight());
            this.framebuffer.createBindFramebuffer(this.displayWidth, this.displayHeight, mainScreenBufferID);
            FileBasicJava.checkGLError("After Start Game");
        }
        catch (Throwable var11)
        {
        	
        	//Show crash report on Screen
            return;
        }
     
        while (true)
        {
            try
            {		
                while (this.running)
                {
                    if (!this.hasCrashed)
                    {
                        try
                        {
                			this.runGameLoop();
                		}
                        catch (OutOfMemoryError var10)
                        {
                            this.freeMemory();
                            
                            System.gc();
                        }
                        continue;
                    }
                  
                    return;
                }
            }
            catch (Error var12)
            {
            	var12.printStackTrace();
            }
            catch (ReportedException var13)
            {
               
                this.freeMemory();
                logger.fatal("Reported exception thrown!", var13);
             
            }
            catch (Throwable var14)
            {           
                this.freeMemory();
                logger.fatal("Unreported exception thrown!", var14);
            }
            finally
            {
            	 this.shutdownApplet();
            }
            
            return;
        }
    }
    
	public static float getFrameTime() 
	{
		return delta;
	}
    
    private void freeMemory(){}

	public int lowFPSwarning = 0;
	private int startUp = 0;
	
    /**
     * Called repeatedly from run()
     */
    private void runGameLoop()
    {
    	FileBasicJava.checkGLError("Start Game Loop");
        if((Display.isCreated() && Display.isCloseRequested()) || this.lowFPSwarning > 100)
        {
            this.shutdown();
        }
        
        if(this.fpsCounter < 10)
        {
        	this.lowFPSwarning += 1;	
        }
        else
        {
        	this.lowFPSwarning = 0;		
        }
        
        if(this.currentScreen!=null && this.currentScreen.doesGuiPauseGame())
        {
        	this.isTimePaused = true;
        }
        else if(this.isTimePaused)
        {
        this.isTimePaused = false;
        }    
      
        if((this.isGamePaused || this.isTimePaused )&& this.theWorld != null)
        {
            float var1 = this.timer.renderPartialTicks;
            this.timer.updateTimer();
            this.timer.renderPartialTicks = var1;
            
            float var2 = this.animatedTimer.renderPartialTicks;
            this.animatedTimer.updateTimer();
            this.animatedTimer.renderPartialTicks = var2;
        }
        else
        {
            this.timer.updateTimer();
            this.animatedTimer.updateTimer();
        }
        MouseControl.checkMouseWheel();
        for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
        {
            this.runTick();
        }
        FileBasicJava.checkGLError("Before render update");
        for (float v = 0; v < this.animatedTimer.elapsedTicks; ++v)
        {
        	for(int id = 0;id < ObjectRenderer.lightObjectsList.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.lightObjectsList.get(id).entity;
        		entity.updateRenderer();
        	}

        	for(int id = 0;id < ObjectRenderer.particles.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.particles.get(id).entity;
        		entity.updateRenderer();
        	}
        	
        	for(int id = 0;id < ObjectRenderer.waterObjectList.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.waterObjectList.get(id).entity;
        		entity.updateRenderer();
        	}
        	
        	for(int id = 0;id < ObjectRenderer.ObjectsRockRenderList.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.ObjectsRockRenderList.get(id).entity;
        		entity.updateRenderer();
        	}
        	
        	for(int id = 0;id < ObjectRenderer.ObjectsOwnTexture.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.ObjectsOwnTexture.get(id).entity;
        		entity.updateRenderer();        
        	}	
      
        	for(int id = 0;id < ObjectRenderer.ObjectsPlantRenderList.size();++id)
        	{
        		BasicEntityRender entity = ObjectRenderer.ObjectsPlantRenderList.get(id).entity;
        		entity.updateRenderer();
        	}
  		
        	for(int id = 0;id < ObjectRenderer.bulletRenderList.size();++id)
  			{
        		BasicEntityRender entity = ObjectRenderer.bulletRenderList.get(id).entity;
        		entity.updateRenderer();
  			}
        	
        	for(int id = 0;id < ObjectRenderer.BodyParts.size();++id)
  			{
        		BasicEntityRender entity = ObjectRenderer.BodyParts.get(id).entity;
        		entity.updateRenderer();
  			}

        	for(int id = 0;id < ObjectRenderer.bulletRenderList.size();++id)
  			{
        		BasicEntityRender entity = ObjectRenderer.bulletRenderList.get(id).entity;
        		entity.updateRenderer();
  			}
  		}

        FileBasicJava.checkGLError("Before render camera");
        if (!this.skipRenderWorld && this.entityRenderer.camera != null)
        {
            this.entityRenderer.camera.updateCameraAndRender(this.timer.renderPartialTicks);
        }
        FileBasicJava.checkGLError("After render camera");
        
        GL11.glFlush();
        if (!Display.isActive() && this.fullscreen)
        {
            this.toggleFullscreen();
        }
        this.prevFrameTime = System.nanoTime(); 
        GL30.glBindFramebuffer(36160, 0); 
        TheStructureWorld.TheStructureWorld.framebuffer.framebufferRender(0,0,TheStructureWorld.TheStructureWorld.displayWidth,TheStructureWorld.TheStructureWorld.displayHeight,TheStructureWorld.TheStructureWorld.mainScreenBufferID);
        this.wasResized();
        if(this.startUp == 0)
        {
        	this.resize(this.displayWidth, this.displayHeight);
        	this.resize(this.displayWidth, this.displayHeight);
        	this.startUp = 1;
        }
        Thread.yield();
        ++this.fpsCounter;
        while (getSystemTime() >= this.debugUpdateTime + 1000L)
        {
            debugFPS = this.fpsCounter;
            this.debug = debugFPS + " fps, ";
            this.debugUpdateTime += 1000L;
            this.fpsCounter = 0;
        }
    }

    public void wasResized()
    {
        Display.update();

        if(this.wasResized)
        {
        	++this.timerResized;
        }
        
        if(this.timerResized > 100)
        {
        	this.wasResized = false;
        	this.timerResized = 0;
        }
        
        if (!this.fullscreen && Display.wasResized())
        {
        	this.wasResized = true;
            int var1 = this.displayWidth;
            int var2 = this.displayHeight;
            this.displayWidth = Display.getWidth();
            this.displayHeight = Display.getHeight();

            if (this.displayWidth != var1 || this.displayHeight != var2)
            {
                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }

                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }

                this.resize(this.displayWidth, this.displayHeight);
            }
        }
    }

    
    /**
     * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
     */
    public void shutdown()
    {
        this.running = false;
        if(EntityRenderer.nmr != null)
        {
        	EntityRenderer.nmr.cleanUp();
        }
    }
   
    public void setIngameFocus()
    {
        if (Display.isActive())
        {
            if (!this.inGameHasFocus)
            {
                this.inGameHasFocus = true;
                this.mouseHelper.grabMouseCursor();
                this.displayGuiScreen((GuiScreen)null);
                this.leftclickCounter = 10000;
            }
        }
    }

    /**
     * Resets the player keystate, disables the ingame focus, and ungrabs the mouse cursor.
     */
    public void setIngameNotInFocus()
    {
        if (this.inGameHasFocus)
        {
            KeyBinding.unPressAllKeys();
            this.inGameHasFocus = false;
            this.mouseHelper.ungrabMouseCursor();
        }
    }

    /**
     * Displays the ingame menu
     */
    public void displayInGameMenu()
    {
        if (this.currentScreen == null)
        {
            this.displayGuiScreen(new IngameMenuAndOptionsGui());
        }
    }
    
    /**
     * Toggles fullscreen mode.
     */
    public void toggleFullscreen()
    {
        try
        {
            this.fullscreen = !this.fullscreen;

            if (this.fullscreen)
            {
                this.displayWidth = Display.getDisplayMode().getWidth();
                this.displayHeight = Display.getDisplayMode().getHeight();

                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }
                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }
            }
            else
            {
             
                if (this.displayWidth <= 0)
                {
                    this.displayWidth = 1;
                }

                if (this.displayHeight <= 0)
                {
                    this.displayHeight = 1;
                }
            }
            
            if (this.currentScreen != null)
            {
                this.resize(this.displayWidth, this.displayHeight);
            }
         
            Display.setFullscreen(this.fullscreen);
            this.wasResized();
        }
        catch (Exception var2)
        {
            logger.error("Couldn\'t toggle fullscreen", var2);
        }
    }

    /**
     * Called to resize the current screen.
     */
    private void resize(int x, int y)
    {
    	this.displayWidth = x <= 0 ? 1 : x;
        this.displayHeight = y <= 0 ? 1 : y;
        ScaledResolution sr = new ScaledResolution(this,x, y);
        if(this.currentScreen != null)
        {
        	this.currentScreen.setWorldAndResolution(this, sr.getScaledWidth(), sr.getScaledHeight());
        }
        this.framebuffer.createBindFramebuffer(this.displayWidth, this.displayHeight, mainScreenBufferID);
        this.entityRenderer.buffer = new WaterFrameBuffers();
    }
    
    /**
     * Runs the current tick.
     */
    public void runTick()
    {
        if(!this.isTimePaused && !this.isGamePaused &&this.theWorld != null)
        {
        	this.theWorld.updateEntities(false);
        }
        else if(this.theWorld != null)
        {
        	this.theWorld.updateEntities(true);
        }
        
        
        //source.delete();

        
        if (!this.isGamePaused)
        {
            this.ingameGUI.updateTick();
        }
        
        this.entityRenderer.getMouseOver(1.0F); 
        
        if (this.theWorld != null)
        {
            this.playerController.updateController();
        }

        if (!this.isGamePaused)
        {
            this.renderEngine.tick();
        }

        if (this.currentScreen != null)
        {
            this.leftclickCounter = 10000;
        }

        if (this.currentScreen != null)
        {
            try
            {
                this.currentScreen.handleInput();
            }
            catch (Throwable var6)
            {
               
            }

            if (this.currentScreen != null)
            {
                try
                {
                    this.currentScreen.updateScreen();
                }
                catch (Throwable var5)
                {
                   
                }
            }
        }

        if (this.currentScreen == null)
        {
            int var9;

            while (Mouse.next())
            {
                var9 = Mouse.getEventButton();
                KeyBinding.setKeyBindState(var9 - 100, Mouse.getEventButtonState());

                if (Mouse.getEventButtonState())
                {
                    KeyBinding.onTick(var9 - 100);
                }

                long var11 = getSystemTime() - this.systemTime;

                if (var11 <= 200L)
                {
                    int var4 = Mouse.getEventDWheel();

                    if (var4 != 0)
                    {
                       if (this.gameSettings.noclip)
                        {
                            if (var4 > 0)
                            {
                                var4 = 1;
                            }

                            if (var4 < 0)
                            {
                                var4 = -1;
                            }

                            this.gameSettings.noclipRate += (float)var4 * 0.25F;
                        }
                    }

                    if (this.currentScreen == null)
                    {
                        if (!this.inGameHasFocus && Mouse.getEventButtonState())
                        {
                            this.setIngameFocus();
                        }
                    }
                    else if (this.currentScreen != null)
                    {
                        this.currentScreen.handleMouseInput();
                    }
                }
            }

            if (this.leftclickCounter > 0)
            {
                --this.leftclickCounter;
            }
            boolean var10;

            while (Keyboard.next())
            {
                KeyBinding.setKeyBindState(Keyboard.getEventKey(), Keyboard.getEventKeyState());

                if (Keyboard.getEventKeyState())
                {
                    KeyBinding.onTick(Keyboard.getEventKey());
                }

                if (Keyboard.getEventKeyState())
                {
                    if (this.currentScreen != null)
                    {
                        this.currentScreen.handleKeyboardInput();
                    }
                    else
                    {
                        if (Keyboard.getEventKey() == 1)
                        {
                            this.displayInGameMenu();
                        }
                    }
                }
            }
        }
        if (this.theWorld != null)
        {
            if (!this.isGamePaused)
            {
                this.entityRenderer.updateRenderer();
            }

            if (!this.isGamePaused)
            {
                if (this.theWorld.lastLightningBolt > 0)
                {
                    --this.theWorld.lastLightningBolt;
                }
             }
        }

        if (this.theWorld != null)
        {
            if (!this.isGamePaused)
            {
                this.theWorld.setAllowedSpawnTypes(this.theWorld.difficultySetting.contains("Peaceful"), true);

                try
                {
                    this.theWorld.tick();
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    if (this.theWorld == null)
                    {
                       System.out.println("[Client thread/ERROR]: Client World == null!");
                    }
                    else
                    {
                    	System.out.println("[Client thread/ERROR]: "+e.getMessage());
                    }
                }
            }
        }
        else if (this.myNetworkManager != null)
        {
            this.myNetworkManager.processReceivedPackets();
        }

        
        this.systemTime = getSystemTime();
    }

    /**
     * Arguments: World foldername,  World ingame name, WorldSettings
     */
    public void launchIntegratedServer(String funci_71371_1_, String funci_71371_2_, WorldSettings funci_71371_3_)
    {
        this.loadWorld((WorldClient)null);
        System.gc();
        ISaveHandler var4 = this.saveLoader.getSaveLoader(funci_71371_1_, false);
        StructureWorldInfo var5 = var4.loadStructureWorldInfo();

        if (var5 == null && funci_71371_3_ != null)
        {
            var5 = new StructureWorldInfo(funci_71371_3_, funci_71371_1_);
            var4.saveStructureWorldInfo(var5);
        }

        if (funci_71371_3_ == null)
        {
            funci_71371_3_ = new WorldSettings(var5);
        }

        try
        {
            this.theIntegratedServer = new IntegratedServer(this, funci_71371_1_, funci_71371_2_, funci_71371_3_);
            this.theIntegratedServer.startServerThread();
            this.integratedServerIsRunning = true;
        }
        catch (Throwable var10)
        {        
            //"Starting integrated server" 	"Level ID", funci_71371_1_		"Level Name", funci_71371_2_
        }

        while (!this.theIntegratedServer.serverIsInRunLoop())
        {
            try
            {
                Thread.sleep(200L);
            }
            catch (InterruptedException var9)
            {
                ;
            }
        }
        SocketAddress var11 = this.theIntegratedServer.tsw_funci_147137_ag().addLocalEndpoint();
        NetworkManager var12 = NetworkManager.provideLocalClient(var11);
        var12.setNetHandler(new NetHandlerLoginClient(var12, this, new LoadingScreenGui(funci_71371_1_)));
        var12.scheduleOutboundPacket(new INetHandlerHandshakeServer.C00Handshake(5, var11.toString(), 0, EnumConnectionState.LOGIN), new GenericFutureListener[0]);
        var12.scheduleOutboundPacket(new C00PacketLoginStart(this.getSession().getProfile()), new GenericFutureListener[0]);
        this.myNetworkManager = var12;
    }

    /**
     * unloads the current world first
     */
    public void loadWorld(WorldClient funci_71403_1_)
    {
        this.loadWorld(funci_71403_1_, "");
    }

    /**
     * par2Str is displayed on the loading screen to the user unloads the current world first
     */
    public void loadWorld(WorldClient funci_71353_1_, String funci_71353_2_)
    {
        if (funci_71353_1_ == null)
        {
            NetHandlerPlayClient var3 = this.getNetHandler();

            if (var3 != null)
            {
                var3.cleanup();
            }

            if (this.theIntegratedServer != null)
            {
                this.theIntegratedServer.initiateShutdown();
            }

            this.theIntegratedServer = null;
        }

        this.renderViewEntity = null;
        this.myNetworkManager = null;

       
        if (funci_71353_1_ == null && this.theWorld != null)
        {
            this.setServerData((ServerData)null);
            this.integratedServerIsRunning = false;
        }
        this.theWorld = funci_71353_1_;

        if (funci_71353_1_ != null)
        {
            if (this.entityRenderer != null)
            {
                this.entityRenderer.setWorldAndLoadRenderers(funci_71353_1_);
            }

            if (this.thePlayer == null)
            {
                this.thePlayer = this.playerController.createNewPlayerMP(funci_71353_1_);
                this.playerController.flipPlayer(this.thePlayer);
            }

            funci_71353_1_.spawnEntityInWorld(this.thePlayer);
            this.thePlayer.movementInput = new MovementInputFromOptions();
            this.playerController.setPlayercapAbilities(this.thePlayer);
            this.renderViewEntity = this.thePlayer;
        }
        else
        {
            this.saveLoader.flushCache();
            this.thePlayer = null;
        }

        System.gc();
        this.systemTime = 0L;
    }

    public void setSpawnPlayer(int funci_71354_1_)
    {
        this.theWorld.setSpawnLocation();
        this.theWorld.removeAllEntities();
        int var2 = 0;
        String var3 = null;

        if (this.thePlayer != null)
        {
            var2 = this.thePlayer.getEntityId();
            this.theWorld.removeEntity(this.thePlayer);
            var3 = this.thePlayer.getName();
        }

        this.renderViewEntity = null;
        this.renderViewEntity = this.thePlayer;
        this.thePlayer.setName(var3);
        this.theWorld.spawnEntityInWorld(this.thePlayer);
        this.playerController.flipPlayer(this.thePlayer);
        this.thePlayer.movementInput = new MovementInputFromOptions();
        this.thePlayer.setEntityId(var2);
        this.playerController.setPlayercapAbilities(this.thePlayer);

     
    }

    public NetHandlerPlayClient getNetHandler()
    {
        return this.thePlayer != null ? this.thePlayer.sendQueue : null;
    }

    public static boolean isGuiEnabled()
    {
        return TheStructureWorld == null || !TheStructureWorld.gameSettings.hideGUI;
    }

    /**
     * Returns if ambient occlusion is enabled
     */
    public static boolean isAmbientOcclusionEnabled()
    {
        return TheStructureWorld != null && TheStructureWorld.gameSettings.ambientOcclusion != 0;
    }

    
    /**
     * Return the singleton StructureWorld instance for the game
     */
    public static TheStructureWorld getTheStructureWorld()
    {
        return TheStructureWorld;
    }

    public void scheduleResourcesRefresh()
    {
        this.refreshTexturePacksScheduled = true;
    }


    /**
     * Set the current ServerData instance.
     */
    public void setServerData(ServerData funci_71351_1_)
    {
        this.currentServerData = funci_71351_1_;
    }

    public ServerData tsw_funci_147104_D()
    {
        return this.currentServerData;
    }

    public boolean isIntegratedServerRunning()
    {
        return this.integratedServerIsRunning;
    }

    /**
     * Returns true if there is only one player playing, and the current server is the integrated one.
     */
    public boolean isSingleplayer()
    {
        return this.integratedServerIsRunning && this.theIntegratedServer != null;
    }

    /**
     * Returns the currently running integrated server
     */
    public IntegratedServer getIntegratedServer()
    {
        return this.theIntegratedServer;
    }

    public static void stopIntegratedServer()
    {
        if (TheStructureWorld != null)
        {
            IntegratedServer var0 = TheStructureWorld.getIntegratedServer();

            if (var0 != null)
            {
                var0.stopServer(false);
            }
        }
    }

    /**
     * Gets the system time in milliseconds.
     */
    public static long getSystemTime()
    {
        return Sys.getTime() * 1000L / Sys.getTimerResolution();
    }

    /**
     * Returns whether we're in full screen or not.
     */
    public boolean isFullScreen()
    {
        return this.fullscreen;
    }
    
    /**
     * Returns whether we're in full screen or not.
     */
    public void setFullScreen(boolean setFullScreen)
    {
    	this.fullscreen = setFullScreen;
    }

    public Session getSession()
    {
        return this.session;
    }

    public Proxy getProxy()
    {
        return this.proxy;
    }

    public TextureManager getTextureManager()
    {
        return renderEngine;
    }

    public boolean isJava64bit()
    {
        return this.jvm64bit;
    }


    static final class SwitchMovingObjectType
    {
        static final int[] i = new int[MovingObjectPosition.MovingObjectType.values().length];
    
        static
        {
            try
            {
                i[MovingObjectPosition.MovingObjectType.ENTITY.ordinal()] = 1;
            }
            catch (NoSuchFieldError var2)
            {
                ;
            }

            try
            {
                i[MovingObjectPosition.MovingObjectType.TerrainObject.ordinal()] = 2;
            }
            catch (NoSuchFieldError var1)
            {
                ;
            }
        }
    }
}
