package nl.thestructureworld.client.renderer.terrain;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import javax.imageio.ImageIO;

import org.apache.commons.io.FileUtils;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;
import org.lwjgl.util.vector.Vector3f;
import org.lwjgl.util.vector.Vector4f;

import nl.thestructureworld.client.FileBasicJava;
import nl.thestructureworld.client.TheStructureWorld;
import nl.thestructureworld.client.gui.IngameMenuAndOptionsGui;
import nl.thestructureworld.client.renderer.EntityRenderer;
import nl.thestructureworld.client.renderer.entity.EntityRockRenderer;
import nl.thestructureworld.client.renderer.entity.ModelBasic;
import nl.thestructureworld.client.renderer.entity.arrays.ArrayListTerrain;
import nl.thestructureworld.client.shaders.CameraAndPlayerAnimations;
import nl.thestructureworld.client.shaders.Loader;
import nl.thestructureworld.client.shaders.RawModel;
import nl.thestructureworld.client.water.WaterTile;
import nl.thestructureworld.entity.Entity;
import nl.thestructureworld.entity.EntityLivingBase;
import nl.thestructureworld.server.TheStructureWorldServer;
import nl.thestructureworld.terrainandobjects.TerrainObject;
import nl.thestructureworld.world.World;

public class Terrain 
{
	public static String seed = "666691204";
	public float X = -5.5F;
	public float Z = -5.5F;
	public static BufferedImage worldMap;
	public static Random rand = new Random();
	public static World world = TheStructureWorld.theWorld;
	public static String worldFolderName;
	static float heightR = 154;
	static int heightG = 1;
	static float heightB = 0;
	static float heightA = 0;
	public float Height = 0;
	static float heightStandard = 154;
    public static List<ArrayListBlendMap> blendMapList = new ArrayList<ArrayListBlendMap>();
  
	public Terrain(String folderName)
	{
		
		try
		{
			worldFolderName = folderName;
			worldMap = ImageIO.read(new File(FileBasicJava.source+"/The Structure World/saves/"+folderName+"/blendMap.png"));
		}
		catch(IOException e)
		{
			System.out.println("Warning: No world Map found!");
			System.out.println("Location: "+FileBasicJava.source+"/The Structure World/saves/"+folderName+"/blendMap.png");
		}
	}
	
	/**
	 * Float Array for Biome Data:
	 * Using Texture:
	 * Float 1: 1-3  How much Terrain Texture 1 will be random generated(Grass)
	 * Float 2: 1-3  How much Terrain Texture 2 will be random generated(Mossy Rock)
	 * Float 3: 1-3  How much Terrain Texture 3 will be random generated(Yellow Clay)
	 * @Comment: These '()' are the Basic Textures used now.
	 * 
	 * Roughness Terrain: 
	 * Float 1: (Grass)
	 * Float 2: (Mossy Rock)
	 * Float 3: (Yellow Clay)
	 */
	public static float[] biomeDifferences = 
	new float[]{
		3,2,7,
		1F,1.2F,1F,
		0F
	};
	
	static int width = 2500;
	static int height = 2500;
	static TerrainObjectList generate = new TerrainObjectList();
	
	public static int addBlendMaps(String code)
	{
		//Random Blendmaps
  	  	if((code.charAt(code.length()-2) + "").contains("3") || (code.charAt(code.length()-2) + "").contains("1") || (code.charAt(code.length()-2) + "").contains("8"))
  	  	{
  	  		heightG += 100;
  	  		return 1; 
  	  	}
  	  	else if((code.charAt(code.length()-2) + "").contains("5") || (code.charAt(code.length()-2) + "").contains("0") || (code.charAt(code.length()-2) + "").contains("9"))
  	  	{
  	  		heightG += 200;
  	  		return 2; 
  	  	}
  	  	else return 0;
	}
	
	/**
	 * Generates either an Flat World (Can be Edited in Forge Mode) or the Standard World but that can be altered before creating the World
	 * @param seed: A random number generated by the game....
	 * @param worldName: Name of the World and the Folder Name
	 * @param flatworld: Flat World for Custom Maps/Forge Mode Maps
	 * @param biomeDifferences: see biomeDifferences.....
	 * 
	 * 
	 * removeTerrainTypes: World Generates: 0 = background terrain(Dirt), 1 = texture terrain 1(Grass), 2 = texture terrain 2(Moss Rock),3 = texture terrain 3(Yellow Clay)
	 */
	public static void createWorldmap(int seed,String worldName,boolean flatworld,float[] biomeDifferences)
	{  
	  generate.seed = seed;
    
      
      //Read BlendMapTextures from the list
      int blendmaps;
      try 
      {
    	  try
		  {
    		  File file = new File(FileBasicJava.source,"/The Structure World/saves/" + worldName +"/Terrain Maps/Custom Blendmap List.txt");
    		  LineNumberReader lineNumberReader = new LineNumberReader(new FileReader(file));
    		  lineNumberReader.skip(Long.MAX_VALUE);
    		  blendmaps = 1 + lineNumberReader.getLineNumber();
    		  lineNumberReader.close();
		  }
    	  catch (IOException e)
  	  	  {
    		  File file = new File(FileBasicJava.source,"/The Structure World/objectsandterrain/Ground/blendmaps/Blendmap List.txt");
        	  LineNumberReader lineNumberReader = new LineNumberReader(new FileReader(file));
        	  lineNumberReader.skip(Long.MAX_VALUE);
        	  blendmaps = 1 + lineNumberReader.getLineNumber();
        	  lineNumberReader.close();
  	  	  }
      } 
      catch (IOException e1)
      {
    	  e1.printStackTrace();
    	  blendmaps = 0;
      }

      System.out.println("***Terrain BlendMap List***");
      for(int bm = 1;bm < blendmaps;++bm)
      {
    		try
    		{
				blendMapList.add(new ArrayListBlendMap((FileUtils.readLines(new File(FileBasicJava.source,"/The Structure World/saves/" + worldName +"/Terrain Maps/Custom Blendmap List.txt")).get(bm))));
				System.out.println("Added to List from custom world: " + blendMapList.get(bm - 1).texture);
			}
    		catch (IOException e)
    		{
				try
				{
					blendMapList.add(new ArrayListBlendMap((FileUtils.readLines(new File(FileBasicJava.source,"/The Structure World/objectsandterrain/Ground/blendmaps/Blendmap List.txt")).get(bm))));
					System.out.println("Added to List: " + blendMapList.get(bm - 1).texture);
				}
				catch (IOException e2)
				{
					e2.printStackTrace();}
				}
      }
      System.out.println("***End List***");
      //End
      //Generate 0.1 Meters
      BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
      Graphics2D g2d = bufferedImage.createGraphics(); 
      for(int x = 0;x <= width;++x)
      {
    	  for(int z = 0;z <= height;++z)
          {
    		  int removeTerrainTypes = 0;
    		  int removeBlendTypes = 0;
    		  if(!flatworld)
    		  {
    			String code = "" + ((x + 2)*(z + 1)*seed);
    			//Random 'small' heights
    			if(biomeDifferences[6] == 1)
    			{
    				if(code.contains("3"))
          	  		{
    					heightG = 1;
          	  		}
    				else
    				{
    				
    					float minusHeight = Float.parseFloat(code.charAt(code.length()-1) + "");
    					float maxHeight = Float.parseFloat(code.charAt(code.length()-1) + "");
    				
    					if(code.contains("0") && (heightG - minusHeight) > 0)
              	  		{
    						heightG -= minusHeight;
              	  		}
    					else if((code.contains("2") || code.contains("8")) && (heightG + maxHeight) < 4)
    					{
    						heightG += maxHeight;
    					}
    					
    				}
    			}
    			//Add one of the few different Terrain Textures
          	  	for(int B1 = 0;B1 < biomeDifferences[0];++B1)
          	  	{
          	  		if((code.charAt(code.length()-1) + "").contains("" + B1))
          	  		{
          	  			if(heightG * biomeDifferences[3]  < 9)
          	  			{
          	  				heightG = (int) (heightG * biomeDifferences[3]);
          	  			}
          	  			heightG += 10;
          	  			removeBlendTypes = addBlendMaps(code);
          	  			removeTerrainTypes = 1;
          	  		}
          	  	}
          	  	
          	  	for(int B2 = (int) biomeDifferences[0];B2 < biomeDifferences[0] + biomeDifferences[1];++B2)
        	  	{
        	  		if((code.charAt(code.length()-1) + "").contains("" + B2))
        	  		{
        	  			if(heightG * biomeDifferences[4] < 9)
          	  			{
          	  				heightG = (int) (heightG * biomeDifferences[4]);
          	  			}
        	  			heightG += 20;
        	  			removeBlendTypes = addBlendMaps(code);
        	  			removeTerrainTypes = 2;
        	  		}
        	  	}
          	  	
          	  	for(int B3 = (int) (biomeDifferences[0] + biomeDifferences[1]);B3 < biomeDifferences[0] + biomeDifferences[1] + biomeDifferences[2];++B3)
        	  	{
        	  		if((code.charAt(code.length()-1) + "").contains("" + B3))
        	  		{
        	  			if(heightG * biomeDifferences[5]  < 9)
          	  			{
          	  				heightG = (int) (heightG * biomeDifferences[5]);
          	  			}
        	  			heightG += 30;
        	  			removeBlendTypes = addBlendMaps(code);
        	  			removeTerrainTypes = 3;
        	  		}
        	  	}
          	  	
          	  try
          	  {
          			if(rand.nextInt(200) == 0)
          			{
          			  	for(int bm = 1;bm < blendmaps;++bm)
          			  	{
          			  		String areaCode = blendMapList.get(bm - 1).areaCode;
          				    for(int xx = 0;xx < blendMapList.get(bm - 1).blendmapImage.getWidth();++xx)
          					{
          						for(int zz = 0;zz < blendMapList.get(bm - 1).blendmapImage.getHeight();++zz)
          						{
          							int Alpha = 0xFF & (blendMapList.get(bm - 1).blendmapImage.getRGB(xx,zz) >> 24);
          							
          							float heightA = Alpha;
          							if(xx + x < width && zz + z < height)
          							{
          								if(blendMapList.get(bm - 1).generateHeights == 1 || (areaCode.contains("566") && blendMapList.get(bm - 1).generateHeights == 0))
          								{
          									
          								}
          								else
          								{
          									
          								}
          								//heightG = (int)(height - heightR);
          								g2d.setColor(new Color(heightA * 0.00392156862745098F, heightG * 0.00392156862745098F, heightB * 0.00392156862745098F, 1F));
          								g2d.fillRect(x, z, 1, 1);  
          							}
          						}
          					}
          			  	}
          		}
          			
          		//g2d.setColor(new Color(heightR * 0.00392156862745098F, heightG * 0.00392156862745098F, heightB * 0.00392156862745098F, 1F));
		        //g2d.fillRect(x, z, 1, 1);
		        
		        
          	  }
          	  catch(Exception e)
          	  {
          		e.printStackTrace();
          	  }
          	  //Reset all
        	  if(removeTerrainTypes==1){heightG-=10;}
        	  if(removeTerrainTypes==2){heightG-=20;}
        	  if(removeTerrainTypes==3){heightG-=30;}
        	  if(removeTerrainTypes>0){removeTerrainTypes=0;}
        	  
        	  if(removeBlendTypes==1){heightG-=100;}
        	  if(removeBlendTypes==2){heightG-=200;}
        	  if(removeBlendTypes>0){removeBlendTypes=0;}
        	  heightR = heightStandard;
    		  }
    		  else
    		  {
    			  g2d.setColor(new Color(heightR * 0.00392156862745098F, heightG * 0.00392156862745098F, heightB * 0.00392156862745098F, 1F));
            	  g2d.fillRect(x, z, 1, 1);
         	  } 
          }
      }
      g2d.dispose();
      //Generate blendmaps
      
      BufferedImage terrainBlendMaps = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
      Graphics2D graphics2DBlendMap = terrainBlendMaps.createGraphics(); 
      
      for(int x = 0;x <= width;++x)
      {
      for(int z = 0;z <= height;++z)
      {
      
      	
        }
      }
      graphics2DBlendMap.dispose();
      
      
      
      //end   
      //Smooth Terrain Final
      BufferedImage terrainFixerImageFinal = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
      Graphics2D graphics2DterrainFixer = terrainFixerImageFinal.createGraphics(); 
     
      for(int xx = 0;xx <= width;++xx)
      {
    	  for(int zz = 0;zz <= height;++zz)
          {
    		  if(xx > 4 && zz > 4 && xx < width - 4 && zz < height - 4)
    		  {
    			  try
    			  {
    				 int Blue;
    				 for(int AreaGreenX = -2;AreaGreenX < 3;++AreaGreenX)
    				 {
    					 for(int AreaGreenZ = -2;AreaGreenZ < 3;++AreaGreenZ)
        				 {
    						 GreenValueFix += ((0xFF & (bufferedImage.getRGB(AreaGreenX + xx,AreaGreenZ + zz) >> 8))); 
    						 ValueFixTimer += 1;
        				 }
    				 }
    				 GreenValueFix /= ValueFixTimer;
    				 String finalGreen = "" + GreenValueFix;
    				 String code = "" + ((xx + 1) * (zz + 1)*seed);
    				 
    				if(finalGreen.length() > 2 && Integer.parseInt(finalGreen.substring(finalGreen.length() - 2, finalGreen.length() - 1)) == 1)
 					{
 						Blue = (int)generate.generateAtGrassTerrain(code, xx, zz, finalGreen.substring(finalGreen.length() - 3, finalGreen.length() - 2));
 					}
 					else if(finalGreen.length() > 2 && Integer.parseInt(finalGreen.substring(finalGreen.length() - 2, finalGreen.length() - 1)) == 2)
 					{
 						Blue = (int)generate.generateAtRockTerrain(code, xx, zz);
 					}
 					else if(finalGreen.length() > 2 && Integer.parseInt(finalGreen.substring(finalGreen.length() - 2, finalGreen.length() - 1)) == 3)
 					{
 						Blue = (int)generate.generateAtGroundTerrain(code, xx, zz);
 					}
 					else 
 					{
 						Blue = (int)generate.generateAtBasicTerrain(code, xx, zz);
 					}
    				 
    				 String GreenFixedHeight = GreenValueFix + "";
    				 int GreenInSmallHeights = Integer.parseInt(GreenFixedHeight.substring(GreenFixedHeight.length() - 1, GreenFixedHeight.length())) / 2;
    				
    				 
    				 String GreenOriginal = "" + (0xFF & (bufferedImage.getRGB(xx,zz) >> 8));
    				 int GreenFinal =  GreenInSmallHeights + (Integer.parseInt(GreenOriginal) - Integer.parseInt(GreenOriginal.substring(GreenOriginal.length() - 1, GreenOriginal.length())));
    				
    				 float heightsRedFinal;
    				 
    				 if((0xFF & (bufferedImage.getRGB(xx,zz) >> 16)) == 0) 
               	  	 {
    					 heightsRedFinal = 154;
               	  	 }
    				 else
    				 {
    					 heightsRedFinal = (0xFF & (bufferedImage.getRGB(xx,zz) >> 16));
    				 }
    				 
    				 graphics2DterrainFixer.setColor(new Color(heightsRedFinal * 0.00392156862745098F, GreenFinal * 0.00392156862745098F, Blue * 0.00392156862745098F, 1F));
    				 graphics2DterrainFixer.fillRect(xx, zz, 1, 1);
    				 ValueFixTimer = 0;
    				 GreenValueFix = 0;
    			  }
    			  catch (Exception e) 
    			  {
    				  System.out.println(xx +" : " + zz);
    			  }
    		  }
    		  
          }
      }
		
		//int red = 0xFF & ( argb >> 16);
		//int alpha = 0xFF & (argb >> 24);
		//int blue = 0xFF & (argb >> 0 );
		//int green = 0xFF & (argb >> 8 );
      graphics2DterrainFixer.dispose();
      
      //Create PNG and save it
      File file = new File(FileBasicJava.sources+"/saves/"+worldName+"/blendMap.png");
      try 
      {
		ImageIO.write(terrainFixerImageFinal, "png", file);
		heightR = 154;
		heightG = 1;
		heightB = 0;
		heightA = 0;
		GreenValueFix = 0;
		ValueFixTimer = 0;
	  } 
      catch(IOException e) 
      {
		e.printStackTrace();
	  }
	}
	

	public static void removePixelsFromTexture(String textureInput,float[] skipColor)
	{
		try 
		{
			BufferedImage texture = ImageIO.read(new File(FileBasicJava.source+"/The Structure World/"+ textureInput +".png"));
			int width = texture.getWidth();
			int height = texture.getHeight();
			
			BufferedImage terrainFixerImageFinal = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
   	      	Graphics2D graphics2DterrainFixer = terrainFixerImageFinal.createGraphics(); 
   	      
			for(int x = 0;x < width;++x)
		    {
		    	  for(int z = 0;z < height;++z)
		          {   
		    		 try 
		 			 {
		    			float red = (0xFF & (texture.getRGB(x,z) >> 16));
		    			float green = (0xFF & (texture.getRGB(x,z) >> 8));
		    			float blue = (0xFF & (texture.getRGB(x,z) >> 0));
		    			float alpha = 0xFF & (texture.getRGB(x,z) >> 24);
		    		    //if(alpha < 3)
		    		    {
		    		    	//graphics2DterrainFixer.setColor(new Color(255F * 0.00392156862745098F,255F * 0.00392156862745098F ,255F * 0.00392156862745098F , 0F * 0.00392156862745098F));
		    		    	//graphics2DterrainFixer.fillRect(x, z, 1, 1); 	
		    		    }
		    		    if(red != skipColor[0] && green != skipColor[1] && blue != skipColor[2])
		    		    {
		    		    	graphics2DterrainFixer.setColor(new Color(red * 0.00392156862745098F,green * 0.00392156862745098F ,blue * 0.00392156862745098F , alpha * 0.00392156862745098F));
		    		    	graphics2DterrainFixer.fillRect(x, z, 1, 1); 
		    		    }
		    		    else
		    		    {
		    		    	graphics2DterrainFixer.setColor(new Color(255F * 0.00392156862745098F,255F  * 0.00392156862745098F,255F * 0.00392156862745098F , 0F * 0.00392156862745098F));
		    		    	graphics2DterrainFixer.fillRect(x, z, 1, 1); 
		    		    }
		 			 } 
					 catch (Exception e) 
					 {
						e.printStackTrace();
					 }
		 		}
		     }
		     graphics2DterrainFixer.dispose();
		     try 
			 {
		    	 File file = new File(FileBasicJava.source+"/The Structure World/"+ textureInput +"_Fixed.png");
		    	 ImageIO.write(terrainFixerImageFinal, "png", file);
			 } 
			 catch (IOException e) 
			 {
				e.printStackTrace();
			 }
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		
	}
	

	static int GreenValueFix;
	static int ValueFixTimer;
	
	
	
	/**
	 * Generates little bumps in the terrain to make it more natural.(Takes in the World Seed and X/Z so it will always be the same bump...)
	 * @param X The x position of one of the 9 areas, which contain 11 by 11 'meters'.
	 * @param Z The z position of one of the 9 areas, which contain 11 by 11 'meters'.
	 * @return a float beneath 0.
	 */
	public static float returnHeight(int X,int Z)
	{
		if(seed != null && TheStructureWorld.getTheStructureWorld().theWorld != null && TheStructureWorld.getTheStructureWorld().theWorld.getStructureWorldInfo() != null)
		{
			seed = TheStructureWorld.getTheStructureWorld().theWorld.getStructureWorldInfo().seed;
		}
		
		int XZCode=(X * 3 * Z) * X + (Z * 3 * 7 + X) * Z;
		
		if(XZCode < 0)
		{
			XZCode = -XZCode;
		}
		
		int codeAt=Integer.parseInt((XZCode + "").replace("-", "").substring(0,1));
		
		int height = XZCode %= 5 + (Double.parseDouble(seed.substring(codeAt,codeAt+1)) / 10);
		return Float.parseFloat("0." + height);	
	}
	
	/**
	 * Calculate the Normals to generate shadows...
	 * @param X The x position of one of the 9 areas, which contain 11 by 11 'meters'.
	 * @param Z The z position of one of the 9 areas, which contain 11 by 11 'meters'.
	 * @return
	 */
	public Vector3f calculateNormal(int x,int z)
	{
		//Vector3f normal = new Vector3f((returnHeight(x-1,z)-returnHeight(x+1,z))+0.001F,0.6F,(returnHeight(x,z-1)-returnHeight(x,z+1))+0.001F);
		
		Vector3f normal = new Vector3f(0.001F,0.6F,0.001F);
		normal.normalise();
		return new Vector3f(normal.x,normal.y,normal.z);
	}
	
	public static float getHeightFromMap(int x,int z)
	{
		if(worldMap != null && x > 0  && z > 0 && z < worldMap.getHeight() && x < worldMap.getWidth())
		{	
			String getHeightFromGreen = "" + (0xFF & (worldMap.getRGB(x,z) >> 8));
			int terrains;
			float hsm = Float.parseFloat((getHeightFromGreen.charAt(getHeightFromGreen.length()-1) + "")) / 10F;
			
			if(getHeightFromGreen.length() != 1 && getHeightFromGreen.length() <= 3)
			{
				terrains = Integer.parseInt((getHeightFromGreen.charAt(getHeightFromGreen.length()-2) + ""));
			}
			else
			{
				terrains = 0;
			}
			return (0xFF & (worldMap.getRGB(x,z) >> 16)) + hsm;
		}
		else
		{
			return 154;
		}
	}
	
	public static Random random = new Random();
	  
	public static float getHeightFromMap(int x,int z,boolean loadObjects, List<ArrayListTerrain> ArrayListTerrain)
	{
		if(x < 6 || x > width - 6 || z < 6 || z > width - 6)
		{
			return heightStandard + returnHeight(z,x);
		}
		else if(worldMap != null && x > 0  && z > 0 && z < worldMap.getHeight() && x < worldMap.getWidth())
		{	
			String getHeightFromGreen = "" + (0xFF & (worldMap.getRGB(x,z) >> 8));
			int blendmaps;
			int terrains;
			float hsm = Float.parseFloat((getHeightFromGreen.charAt(getHeightFromGreen.length()-1) + "")) / 10F;
			
			if(getHeightFromGreen.length() == 3)
			{
				blendmaps = Integer.parseInt((getHeightFromGreen.charAt(getHeightFromGreen.length()-3) + ""));
			}
			else
			{
				blendmaps = 0;
			}
			
			if(getHeightFromGreen.length() != 1 && getHeightFromGreen.length() <= 3)
			{
				terrains = Integer.parseInt((getHeightFromGreen.charAt(getHeightFromGreen.length()-2) + ""));
			}
			else
			{
				terrains = 0;
			}
			String areacode;
			int listNumber;
			if(ArrayListTerrain != null)
			{
				ArrayListTerrain.get(0).blendMapCoords = new float[]{blendmaps,terrains,1,1};
				areacode = ArrayListTerrain.get(0).AreaCode;
				listNumber = ArrayListTerrain.get(0).listNumber;
			}
			else
			{
				areacode = (((int)(x/10D)) * (10)) + "_" + (((int)(z/10D)) * (10));
				listNumber = 4;
			}
			
			float heightFinal = (0xFF & (worldMap.getRGB(x,z) >> 16)) + hsm;

			if((0xFF & (worldMap.getRGB(x,z) >> 0)) > 0 && loadObjects)
			{
				generate.generateObject((0xFF & (worldMap.getRGB(x,z) >> 0)),x,z,heightFinal,areacode,listNumber);
			}
			
			if(heightFinal > (heightStandard + 100))
			{
				//heightFinal = heightStandard;
			}
			
			return heightFinal;
		}
		else
		{
			return heightStandard;
		}

	}

	
	/**
	 * @param zStart Start of the area
	 * @param xStart Start of the area
	 * @param ArrayListTerrain
	 * @return: the 11 by 11 area with texture and Normals
	 */
	public RawModel generateTerrain(int zStart,int xStart, List<ArrayListTerrain> ArrayListTerrain)
	{   
		int distance = EntityRenderer.renderDistance * 2;
		int count =  (11 + distance) *  (11 + distance);
		float[] vertices=new float[count*3];
		float[] normals=new float[count*3];
		float[] textureCoords=new float[count*2];
		int[] indices=new int[count*6];
		int vertexPointer=0;
		int pointer=0;
		for(int xx=0;xx <= 10 + distance;++xx)
		{
			for(int zz=0;zz <= 10 + distance;++zz)
			{	
				
				this.Height = getHeightFromMap(zz+zStart,xx+xStart,true,ArrayListTerrain);
				
			    vertices[vertexPointer*3+0] = zz;
				vertices[vertexPointer*3+1] = this.Height;
				vertices[vertexPointer*3+2] = xx;	
				Vector3f normal = calculateNormal(zz+zStart,xx+xStart);
				normals[vertexPointer*3] =   normal.x;
				normals[vertexPointer*3+1] = normal.y;
				normals[vertexPointer*3+2] = normal.z;
				textureCoords[vertexPointer*2] = (xx+xStart) * 0.1F;
				textureCoords[vertexPointer*2+1] = (zz+zStart) * 0.1F;
				vertexPointer++;
				
				if(xx < 10 + distance)
				{
					if(zz < 10 + distance)
					{
						int x = (xx * (11 + distance)) + zz;
						int z = ((xx + 1) * (11 + distance)) + zz;
						indices[pointer++] = x;
						indices[pointer++] = z;
						indices[pointer++] = x+1;
						indices[pointer++] = x+1;
						indices[pointer++] = z;
						indices[pointer++] =  z+1;	
					}
				}
			}
		}
		return new Loader().loadToVAO(vertices, textureCoords, normals, indices);
	}

}